java多线程之内存可见性：synchronized与volatile均可实现内存可见性

-------------------------------基础知识补充-------------------------------
可见性：一个线程对共享变量值的修改，其他线程能够及时的看到。
共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。

java内存模型（JMM）：
    java内存模型（Java Memory Model）描述了java程序中变量（线程共享变量）的访问规则，以及在jvm中变量存储到内存以及从内存中读取变量的底层细节。
    1.所有变量都存储在主内存中。
    2.每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一分拷贝）

Java线程操作共享变量的两条规定：
    1.线程对共享变量的操作必须在自己的工作内存中进行，而不能直接从主内存中读写。
    2.不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过只内存来完成。

重排序：代码书写的顺序与实际执行的顺序不同，指令重排序是指编译器或处理器为了提高程序性能而做的优化。
    1.编译器优化的重排序（编译器优化）
    2.指令级并行重排序（处理器优化）
    3.内存系统的重排序（处理器优化）

as-if-serial：无论如何进行重排序，程序执行的结果应该与代码顺序执行的结果一致
    1.Java编译器/运行时和处理器都会保证Java在单线程下遵循as-if-serial语义，重排序不会给单线程带来内存可见性问题
    2.多线程中程序交叉执行时，重排序可能带来内存可见性问题。

----------------------------------可见性-----------------------------------
共享变量可见性实现原理：线程1对共享变量的修改要被线程2及时看到，必须经过以下两个步骤
    1.把工作内存1中更新过的共享变量刷新到主内存中
    2.将主内存中更新的共享变量的值更新到工作内存2中

实现共享变量的可见性，必须满足一下亮点：
    1.线程修改后的共享变量指能够及时从工作内存刷新到主内存
    2.其他线程能够及时把工作内存变量的最新值从主内存更新到自己的工作内存

Java语言层面支持的可见性实现方式：
    1.synchronized
    2.volatile

------------------------------synchronized实现可见性------------------------
JMM关于关于synchronized两条规定：
    1.线程解锁前，必须把共享变量的最新值刷新到主内存中
    2.线程加锁时，将清空工作内存中共享变量值，从而使用共享变量时需从主内存中重新读取共享变量的值
    注意：加锁和解锁必须时同一把锁；线程解锁前对共享变量值的修改在下次加锁前对其他线程可见。

线程执行互斥代码的过程：
    1.获得互斥锁
    2.清空工作内存中共享变量值
    3.从主内存中拷贝共享变量值最新副本到工作内存
    4.执行代码
    5.将修改后的共享变量值更新到主内存
    6.释放互斥锁

几点：
1.当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。
2.当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。
3.当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

--------------------------------volatile实现可见性--------------------------
volatile关键字：
1.能够保证volitale变量可见性
2.不能保证volitale变量复合操作的原子性（如下）
    private int number = 0;
    number++;
    number++为复合操作，不是原子操作
    1)读取number的值
    2)将number的值加1
    3)写入最新的number的值

    加入synchronized，变为原子操作：
    synchronized(this){
        number++;
    }

    变为volatile，无法保证原子性
    private volatile int number = 0;

volatile如何保证内存可见性：
深入来说：通过加入内存屏障和禁止重排序优化来实现的
    1.对volatile变量进行写操作时，会在写操作后加入一条store屏障指令
    2.对volatile变量进行读操作时，会在读操作后加入一条load屏障指令
通俗的讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样在任何时刻，不同的线程总能看到该变量的最新的值。

线程写volatile变量的过程：
    1.改变线程工作内存中volatile变量副本的值
    2.将改变后的副本的值从工作内存刷新到主内存
线程读volatile变量的过程：
    1.从主内存中读取volatile变量的最新值到线程的工作内存中
    2.从工作内存中读取volatile变量的副本

volatile使用场景：
要在需多线程中安全的使用volatile变量，必须同时满足：
1.对变量的写入操作不依赖当前值（不能与之前的值有关系，涉及原子性问题）
    不满足：number++/count=count*5等
    满足：boolean变量/温度变化等
2.该变量没有包含在具有其他变量的不变式中（程序中有多个volatile变量，每个volatile变量要独立于其它volatile变量）
    例如程序中存在两个volatile变量：up/low，程序中存在low<up的不变式，则不满足
大部分情况下，毁于以上两种之中的一种冲突，所以说volatile并没有synchronized使用广泛！！！

-----------------------------synchronzed VS volatile--------------------------
1.volatile不需要加锁,比synchronized更轻量级,不会阻塞线程
2.从内存可见性角度,volatile读相当于 加锁,volatile写相当于 解锁.
3.synchronized既能保证可见性,又能保证原子性,而volatile只能保证可见性,无法保证原子性.
实际使用中，在保证线程安全的情况下，volatile比较轻量级，可以较多的使用volatile

几点：
1.Java中没有提供检测与避免死锁的专门机制，但应用程序员可以采用某些策略防止死锁的发生
2.JAVA中对共享数据操作的并发控制是采用加锁技术
3.共享数据的访问权限都必须定义为private