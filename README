java多线程之内存可见性：synchronized与volatile均可实现内存可见性

-------------------------------基础知识补充-------------------------------
可见性：一个线程对共享变量值的修改，其他线程能够及时的看到。
共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。

java内存模型（JMM）：
    java内存模型（Java Memory Model）描述了java程序中变量（线程共享变量）的访问规则，以及在jvm中变量存储到内存以及从内存中读取变量的底层细节。
    1.所有变量都存储在主内存中。
    2.每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一分拷贝）

Java线程操作共享变量的两条规定：
    1.线程对共享变量的操作必须在自己的工作内存中进行，而不能直接从主内存中读写。
    2.不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过只内存来完成。

重排序：代码书写的顺序与实际执行的顺序不同，指令重排序是指编译器或处理器为了提高程序性能而做的优化。
    1.编译器优化的重排序（编译器优化）
    2.指令级并行重排序（处理器优化）
    3.内存系统的重排序（处理器优化）

as-if-serial：无论如何进行重排序，程序执行的结果应该与代码顺序执行的结果一致
    1.Java编译器/运行时和处理器都会保证Java在单线程下遵循as-if-serial语义，重排序不会给单线程带来内存可见性问题
    2.多线程中程序交叉执行时，重排序可能带来内存可见性问题。

----------------------------------可见性-----------------------------------
共享变量可见性实现原理：线程1对共享变量的修改要被线程2及时看到，必须经过以下两个步骤
    1.把工作内存1中更新过的共享变量刷新到主内存中
    2.将主内存中更新的共享变量的值更新到工作内存2中

实现共享变量的可见性，必须满足一下亮点：
    1.线程修改后的共享变量指能够及时从工作内存刷新到主内存
    2.其他线程能够及时把工作内存变量的最新值从主内存更新到自己的工作内存

Java语言层面支持的可见性实现方式：
    1.synchronized
    2.volatile

------------------------------synchronized实现可见性------------------------
JMM关于关于synchronized两条规定：
    1.线程解锁前，必须把共享变量的最新值刷新到主内存中
    2.线程加锁时，将清空工作内存中共享变量值，从而使用共享变量时需从主内存中重新读取共享变量的值
    注意：加锁和解锁必须时同一把锁；线程解锁前对共享变量值的修改在下次加锁前对其他线程可见。

线程执行互斥代码的过程：
    1.获得互斥锁
    2.清空工作内存中共享变量值
    3.从主内存中拷贝共享变量值最新副本到工作内存
    4.执行代码
    5.将修改后的共享变量值更新到主内存
    6.释放互斥锁

几点：
1.当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。
2.当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。
3.当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。